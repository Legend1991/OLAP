@{
    ViewBag.Title = "Index";
    Layout = "~/Views/Shared/_Layout.cshtml";
    @Scripts.Render("~/Scripts/three.min.js")
    @Scripts.Render("~/Scripts/Control.js")
    @Scripts.Render("~/Scripts/stats.min.js")
    @Scripts.Render("~/Scripts/TrackballControls.js")
    @Scripts.Render("~/Scripts/THREEx.screenshot.js")
    @Scripts.Render("~/Scripts/markers.js")
}


<table id="marker_template" class="marker" style="left:'-50px';top:'-50px'"><tr><td><span id="measureText" class="measure">Marker</span></td></tr></table>

<div id="sideBar">
	<div style="margin-top: 0px;"><h5>База данных</h5></div>
	<select id="DBSel">
  		<option>Test DB</option>
  		<option>MusicStrore DB</option>
	</select>

	<div id="Dims">
		<div><h5>Измерение X</h5></div>
		<select>
  			<option>Time_Dim</option>
  			<option>Region_Dim</option>
  			<option>Category_Dim</option>
		</select>
		<div><h5>Измерение Y</h5></div>
		<select>
			<option>Region_Dim</option>
  			<option>Time_Dim</option>
  			<option>Category_Dim</option>
		</select>
		<div><h5>Измерение Z</h5></div>
		<select>
			<option>Category_Dim</option>
  			<option>Time_Dim</option>
  			<option>Region_Dim</option>
		</select>
	</div>
    <button id="createCube" class="btn btn-large btn-success" type="button">Построить куб</button>
</div>

<div id="visualizationBorder">
    <div  id="visualization">
  		<ul id="contextMenu" class="dropdown-menu" role="menu" aria-labelledby="dLabel">
    	    <li><a tabindex="-1" href="#">Действие</a></li>
    		<li><a tabindex="-1" href="#">Другое действие</a></li>
    		<li><a tabindex="-1" href="#">Еще ссылка</a></li>
    		<li class="divider"></li>
    		<li><a tabindex="-1" href="#">Доп. ссылка</a></li>
  		</ul>
	</div>
</div>

<div id="debug"></div>

<script>
    $("#CubeNav").addClass("active");
/////////////////// Settings
		    var HEIGHT = 567;
			var	WIDTH = 1093;
		    var DIMX = 0, DIMY = 1; DIMZ = 2;
			var clock = new THREE.Clock();
			var scene = new THREE.Scene();
		    var camera = new THREE.PerspectiveCamera(70, WIDTH / HEIGHT, 1, 10000);
			var projector, raycaster;
			var mouse = new THREE.Vector2(), INTERSECTED, ROLLOVERED;
			var radius = 100;
			var renderer;
			var blockIsMove = false;
			var shiftGroup;
			var face;

			renderer = new THREE.WebGLRenderer({ preserveDrawingBuffer: true, antialias: true });
			renderer.setSize(WIDTH, HEIGHT);
			renderer.domElement.setAttribute("id", "Cnv");
			var visualization = document.getElementById('visualization');
			visualization.appendChild(renderer.domElement);
			var canvas = document.getElementById('Cnv');

			projector = new THREE.Projector();
			raycaster = new THREE.Raycaster();

/////////////////// Stats
			//stats = new Stats();
			//stats.domElement.style.position = 'absolute';
			//document.body.appendChild(stats.domElement);

/////////////////// Screenshots
			//THREEx.Screenshot.bindKey(renderer);

/////////////////// Objects

			var cubesX;
			function makeCube(countX, countY, countZ) {
			    cubesX = Array(countX);
			    for (var xi = 0; xi < countY; xi++) {
			        var cubesY = Array(countY);
			        for (var yi = 0; yi < countY; yi++) {
			            var cubesZ = Array(countZ);
			            for (var zi = 0; zi < countZ; zi++) {
			                var geometry = new THREE.CubeGeometry(1, 1, 1);
			                var material = new THREE.MeshLambertMaterial({ wireframe: false, color: 0x00ff00 });
			                var cube = new THREE.Mesh(geometry, material);
			                cube.position.x = xi;
			                cube.position.y = yi;
			                cube.position.z = zi;
			                cubesZ[zi] = cube;
			                scene.add(cube);
			                var cubeMesh = new THREE.Mesh(new THREE.CubeGeometry(1, 1, 1), new THREE.MeshLambertMaterial({ wireframe: true, color: 0x000000 }));
			                THREE.SceneUtils.attach(cubeMesh, scene, cube);

			                createMarkers(cube);
			            }
			            cubesY[yi] = cubesZ;
			        }
			        cubesX[xi] = cubesY;
			    }
			}

/////////////////// Create markers
			function createMarkers(currCube) {
			    if (currCube.position.x == 4 && currCube.position.z == 0) {
			        attachMarkerToCube("Kharkov", currCube, DIMY);
			    }
			    else if (currCube.position.y == 4 && currCube.position.z == 4) {
			        attachMarkerToCube("Kharkov", currCube, DIMX);
			    }
			    else if (currCube.position.x == 0 && currCube.position.y == 0) {
			        attachMarkerToCube("Kharkov", currCube, DIMZ);
			    }
			}

/////////////////// Clear scene
			function clearScene() {
			    for (var i = scene.children.length - 1; i >= 0 ; i--) {
			        var obj = scene.children[i];
			        if (obj !== plane && obj !== camera) {
			            scene.remove(obj);
			        }
			    }
            }

/////////////////// Lights
			var light = new THREE.PointLight(0xffffff, 1, 10000);
			light.position.set(200, 200, 200);
			scene.add(light);

			var light = new THREE.PointLight(0xffffff, 1, 10000);
			light.position.set(-200, -200, -200);
			scene.add(light);

/////////////////// Controls
			var controls = new THREE.TrackballControls(camera, canvas);
			controls.rotateSpeed = 1.0;
			controls.zoomSpeed = 1.2;
			controls.panSpeed = 0.8;
			controls.noZoom = false;
			controls.noPan = false;
			controls.staticMoving = true;
			controls.dynamicDampingFactor = 0.3;

/////////////////// Find intersections
			var intersect = function () {
			    var vector = new THREE.Vector3(mouse.x, mouse.y, 1);
			    projector.unprojectVector(vector, camera);

			    raycaster.set(camera.position, vector.sub(camera.position).normalize());

			    var intersects = raycaster.intersectObjects(scene.children);

			    if (intersects.length > 0) {
			        //var debug = document.getElementById('debug');
			        //debug.textContent = "OK";
			        if (INTERSECTED != intersects[0].object) {

			            if (INTERSECTED) INTERSECTED.material.emissive.setHex(INTERSECTED.currentHex);

			            INTERSECTED = intersects[0].object;
			            INTERSECTED.currentHex = INTERSECTED.material.emissive.getHex();
			            INTERSECTED.material.emissive.setHex(0xff0000);
			            //if (INTERSECTED.marker) {
			            //    INTERSECTED.marker.setAttribute('style', 'background-color: rgba(255,140,0,.87); color:	#000000;');
			            //}
			            //face = intersects[0].face;
			            //face.currentHex = face.material.emissive.getHex();
			            //face.material.emissive.setHex(0x000000);
			            var debug = document.getElementById("debug");
			            debug.textContent = "X: " + INTERSECTED.position.x + " Y: " + INTERSECTED.position.y + " Z: " + INTERSECTED.position.z;
			        }

			    } else {
			        if (INTERSECTED) INTERSECTED.material.emissive.setHex(INTERSECTED.currentHex);
			        //if (face) face.material.emissive.setHex(face.currentHex);
			        //if (INTERSECTED.marker != null) {
			        //    INTERSECTED.marker.setAttribute('style', 'background-color: rgba(0,0,0,.87); color:	#ffffff;');
			        //}

			        INTERSECTED = null;
			        //face = null;
			        //var debug = document.getElementById("debug");
			        //debug.textContent = "X:  , Y:  , Z:  ";
			    }
		    }

/////////////////// Mouse move
			function onDocumentMouseMove(event) {

			    event.preventDefault();

			    mouse.x = ((event.clientX - 254) / WIDTH) * 2 - 1;
			    mouse.y = -((event.clientY - 81) / HEIGHT) * 2 + 1;

			    //var debug = document.getElementById("debug");
			    //debug.textContent = "X:  " + camera.position.x + " Y:  "+ camera.position.y + " Z: " + camera.position.z;
			   //var debug = document.getElementById("debug");
			   //debug.textContent = "X:  " + INTERSECTED.position.x + " Y:  " + INTERSECTED.position.y + " Z: " + INTERSECTED.position.z;
			}

			function onDocumentMouseUp(event) {
			    if (INTERSECTED != null) {
			        if (blockIsMove == true && checkMovingGroup(DIMY, shiftGroup, INTERSECTED.position.x, INTERSECTED.position.y, INTERSECTED.position.z) == false) {
			            return;
			        }
			        shiftGroup = INTERSECTED.position.y;
			        shift(DIMY, shiftGroup);
			        blockIsMove = !blockIsMove;
			        $('.dropdown-toggle').dropdown();
			    }
			}

			function shift(dim, shiftGroup) {
			    var moveDist = 7;
			    if (blockIsMove == true) {
			        moveDist = -moveDist;
			    }
			    for (var xi = 0; xi < 5; xi++) {
			        for (var yi = 0; yi < 5; yi++) {
			            switch (dim) {
			                case 0:
			                    cubesX[shiftGroup][xi][yi].position.z -= moveDist
			                    break
			                case 1:
			                    cubesX[xi][shiftGroup][yi].position.z -= moveDist
			                    break
			                case 2:
			                    cubesX[xi][yi][shiftGroup].position.x -= moveDist
			                    break
			            }
			        }
			    }
			    //var debug = document.getElementById("debug");
			    //debug.textContent = blockIsMove;
			}

			function checkMovingGroup(dim, shiftGroup, objectX, objectY, objectZ) {
			    //var debug = document.getElementById("debug");
			    switch (dim) {
			        case 0:
			            //debug.textContent = shiftGroup + "  " + objectX
			            return shiftGroup == objectX
			        case 1:
			            //debug.textContent = shiftGroup + "  " + objectY
			            return shiftGroup == objectY
			        case 2:
			            //debug.textContent = shiftGroup + "  " + objectZ
			            return shiftGroup == objectZ
			    }
			}

			function onWindowResize() {

				HEIGHT = $('#visualizationBorder').css('Height');
				WIDTH = $('#visualizationBorder').css('Width');
				camera.aspect = WIDTH / HEIGHT;
				camera.updateProjectionMatrix();

				renderer.setSize( WIDTH, HEIGHT );

				var debug = document.getElementById("debug");
			   	debug.textContent = "Width: " +$('#visualizationBorder').css('Width')+"	Height  " +$('#visualizationBorder').css('Height');
			}

			var canvas = document.getElementById('Cnv');
			canvas.addEventListener('mousemove', onDocumentMouseMove, false);
			canvas.addEventListener('click', onDocumentMouseUp, false);
			//window.addEventListener( 'resize', onWindowResize, false );


/////////////////// Camera settings and Render
			camera.position.x = -3;
			camera.position.y = 10;
			camera.position.z = -3;
			//camera.lookAt(new THREE.Vector3(-10, -10, -10));
			//camera.lookAt(cubesX[4][4][4].position);

			var render = function () {
			    requestAnimationFrame(render);

			    //pick();
			    this.intersect();
			    controls.update();
			    //stats.update();
			    //raycaster = projector.pickingRay(mouse.clone(), camera);
			    renderer.render(scene, camera);
			   	for( var i in markers ){
					var marker = markers[i];
					marker.update();
				}		    	

			};
			makeCube(5, 5, 5);
			render();
</script>